"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateImport = updateImport;
exports.sortImports = sortImports;

var _lodash = require("lodash");

var _recast = require("recast");

var _recast2 = _interopRequireDefault(_recast);

var _compareImports = require("codemod-imports-sort/dist/compareImports");

var _compareImports2 = _interopRequireDefault(_compareImports);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var builders = _recast2.default.types.builders;
var types = _recast2.default.types.namedTypes;

function keys(obj) {
  return Object.keys(obj);
}

function updateImport(ast, importMap) {
  var newStatements = [];
  keys(importMap).forEach(function (importKind) {
    var mapKind = importMap[importKind];
    keys(mapKind).forEach(function (path_) {
      // Combine with exists import if any
      var currentImport = ast.find(types.ImportDeclaration, {
        importKind: importKind,
        source: {
          type: "Literal",
          value: path_
        }
      });

      var initImportInfo = mapKind[path_];

      if (currentImport.size() > 0) {
        // Has some imports => combine all of them to one
        var finalImportInfo = initImportInfo;
        currentImport.forEach(function (path2_) {
          var currentImportInfo = _getImportInfo(path2_.node);
          finalImportInfo = _combineImportInfo(finalImportInfo, currentImportInfo);
        });

        var newImport = _buildPath(finalImportInfo, path_, importKind);

        currentImport.forEach(function (path2_, i) {
          if (i === 0) {
            // console.log("currentImport.at(0)", currentImport.at(0).get());
            if (currentImport.size() > 0) {
              newImport.comments = currentImport.at(0).get().node.comments;
              currentImport.at(0).replaceWith(newImport);
            }
          } else {
            currentImport.at(i).remove();
          }
        });
      } else {
        newStatements.push(_buildPath(initImportInfo, path_, importKind));
      }
    });
  });

  // if (newStatements.length === 0) {
  //   // no import
  //   return;
  // }
  var statements = ast.find(types.Statement);
  if (statements.size() === 0) {
    var s = ast.find(types.Program);
    s.insertAfter(newStatements);
  } else {
    var statement0 = statements.at(0);

    if (!types.ImportDeclaration.check(statement0)) {
      var s0 = statement0.get().node;

      if (newStatements.length > 0) {
        var comments = s0.comments;
        // console.log(s0, s0.name);
        delete s0.comments;
        newStatements[0].comments = comments;
      }
    }

    statement0.insertBefore(newStatements);
  }

  // sort Imports
  sortImports(ast);
}

function sortImports(ast) {
  // console.log('sort import');
  var config = {};
  var declarations = ast.find(types.ImportDeclaration);
  var sortedDeclarations = declarations.nodes().sort(function (a, b) {
    var aImportKind = a.importKind === "value" ? 0 : 1;
    var bImportKind = b.importKind === "value" ? 0 : 1;

    // 'import value' should go before 'import type'
    if (aImportKind < bImportKind) {
      return -1;
    } else if (aImportKind > bImportKind) {
      return 1;
    }

    return (0, _compareImports2.default)(a.source.value, b.source.value, config.groups);
  });

  // console.log(JSON.stringify(ast.get(0).node, null, 2));

  /**
   * Respect the first comment
   * 
   * Input:
   *    // My comment
   *    import A from './A';
   *    import React from 'react';
   * Expect:
   *    // My comment
   *    import React from 'react';
   *    import A from './A';
   * Actual: 
   *    import React from 'react';
   *    // My comment
   *    import A from './A';
   * 
   * Root cause: the comment is attached into node 'import A...', so when the node is moved, the comments are moved too.
   * Solution: Get the comments from the first node before sort and move it the the first node after sort.
   */
  if (sortedDeclarations.length > 0) {
    var firstDeclarationNode = declarations.get(0).node;
    if (firstDeclarationNode) {
      var comments = firstDeclarationNode.comments;

      sortedDeclarations[0].comments = comments;

      // Find the sortedNode
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = sortedDeclarations.slice(1)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var node = _step.value;

          if ((0, _lodash.isEqual)(node, firstDeclarationNode)) {
            delete node.comments;
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }

  ast.find(types.Statement).at(0).insertBefore(sortedDeclarations);

  // console.log(ast.toSource());

  declarations.remove();
  // console.log(ast.toSource());
}

function _getImportInfo(node) {
  var ret = {};

  // Main
  var mainItem = node.specifiers.filter(function (item) {
    return item.type === "ImportDefaultSpecifier" && item.local.type === "Identifier";
  })[0];

  if (mainItem) {
    ret.main = mainItem.local.name;
  }

  // Others
  var others = node.specifiers.filter(function (item) {
    return item.type === "ImportSpecifier" && item.local.type === "Identifier";
  }).map(function (item) {
    var localName = item.local.name;
    var importedName = item.imported.name;
    if (localName === importedName) {
      return localName;
    }

    return importedName + " as " + localName;
  });

  ret.others = others;

  return ret;
}

function _combineImportInfo(info1, info2) {
  var main = info1.main != null ? info1.main : info2.main != null ? info2.main : null;
  var others = (0, _lodash.uniq)([].concat(_toConsumableArray(info1.others || []), _toConsumableArray(info2.others || [])));

  var ret = { others: others };
  if (main != null) {
    ret.main = main;
  }

  return ret;
}

function _buildPath(importInfo, path_, importKind) {
  var main = importInfo.main,
      others = importInfo.others;

  var specifiers = [];
  if (main != null) {
    specifiers.push(builders.importDefaultSpecifier(builders.identifier(main)));
  }

  var others_ = others != null ? others : [];

  specifiers = [].concat(_toConsumableArray(specifiers), _toConsumableArray(others_
  // sort without case sensitive
  .sort(function (a, b) {
    return a.toLowerCase().localeCompare(b.toLowerCase());
  }).map(function (other) {
    return builders.importSpecifier(builders.identifier(other));
  })));
  return builders.importDeclaration(specifiers, builders.literal(path_), importKind);
}