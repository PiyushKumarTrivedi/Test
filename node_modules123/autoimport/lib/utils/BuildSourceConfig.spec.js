"use strict";

var _BuildSourceConfig = require("./BuildSourceConfig");

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

var _fs = require("fs");

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe("getExportInfoFromSource", function () {
  var defaultFile = "components/A.js";

  var d = _path2.default.join(__dirname, "../../__testfixtures__/DetectExport");
  /* eslint-disable no-unused-vars */
  function codeFile(file) {
    /* eslint-enable no-unused-vars */
    var source = _fs2.default.readFileSync(_path2.default.join(d, file)).toString("utf-8");
    return code(source, file);
  }

  function code(source, file) {
    var filePath = file != null ? file : defaultFile;

    var importInfo = (0, _BuildSourceConfig.getExportInfoFromSource)(filePath, source);

    var checker = {
      hasOthers: function hasOthers() {
        var others = importInfo.others || [];

        for (var _len = arguments.length, members = Array(_len), _key = 0; _key < _len; _key++) {
          members[_key] = arguments[_key];
        }

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = members[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var member = _step.value;

            expect(others).toContain(member);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return checker;
      },
      hasOtherTypes: function hasOtherTypes() {
        var others = importInfo.types || [];

        for (var _len2 = arguments.length, members = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          members[_key2] = arguments[_key2];
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = members[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var member = _step2.value;

            expect(others).toContain(member);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        return checker;
      },
      hasMain: function hasMain(member) {
        expect(importInfo.main).toBe(member);

        return checker;
      },
      notHasMain: function notHasMain() {
        expect(importInfo.main).toBeUndefined();

        return checker;
      }
    };

    return checker;
  }

  // fit("debug", () => {
  //   codeFile("debug.js")
  //     .hasOthers("A")
  //     .notHasMain();
  // });

  it("export function", function () {
    code("\n      export function A();\n    ").hasOthers("A").notHasMain();
  });

  it("export idenfiers", function () {
    code("\n      export const A = 1;\n      export let B = 2, C=3;\n    ").hasOthers("A", "B", "C").notHasMain();
  });

  it("export identifier as another name", function () {
    code("\n      const A = 1;\n      const B = 2;\n\n      export {A, B as B1};\n    ").hasOthers("A", "B1").notHasMain();
  });

  it("export default in non-index file will be file name", function () {
    code("\n      export default 1;\n    ", "/ABC.js").hasMain("ABC");
  });

  it("export default in index.js will be detected name base on folder name", function () {
    code("\n      export default 1;\n    ", "/ABC/index.js").hasMain("ABC");
  });

  it("export type and value", function () {
    code("\n    export type TUser = {\n      name: string,\n    }\n\n    export const A = 1;\n    export default 2;\n    ", "/ABC.js").hasOtherTypes("TUser").hasMain("ABC").hasOthers("A");
  });
});

describe("scanSourceDir", function () {
  it("could scan dir", function () {
    var d = _path2.default.join(__dirname, "../../__testfixtures__/sample1");

    var packagesFromSource = (0, _BuildSourceConfig.scanSourceDir)(d);
    // console.log(typeOptionsSource);
    expect(packagesFromSource["./A"]).toBeDefined();
    expect(packagesFromSource["./B"]).toBeDefined();

    expect(packagesFromSource).toMatchSnapshot();

    expect(packagesFromSource["./B/types"]).toBeDefined();
    expect(packagesFromSource).toMatchSnapshot();
  });
});