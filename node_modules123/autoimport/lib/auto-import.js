"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformByConfigProvider = undefined;

var _DetectUndefinedIdentifier = require("./DetectUndefinedIdentifier");

var _DetectUndefinedIdentifier2 = _interopRequireDefault(_DetectUndefinedIdentifier);

var _ConfigProvider = require("./ConfigProvider");

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

var _ImportUtils = require("./utils/ImportUtils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var baseTransform = function baseTransform(file, api, rootPath, _getImport, _getImportType) {
  // console.log("rp", rootPath, file.path);
  var j = api.jscodeshift;

  // Find undefined nodes
  var ast = j(file.source);

  var _DetectUndefinedIdent = (0, _DetectUndefinedIdentifier2.default)(ast),
      missedIdentifiers = _DetectUndefinedIdent.identifiers,
      missedTypes = _DetectUndefinedIdent.types,
      unusedImports = _DetectUndefinedIdent.unusedImports;

  (0, _DetectUndefinedIdentifier.removeImportIdentifiers)(j, ast, unusedImports);
  // console.log("missed", missedIdentifiers);
  // console.log("missed type", missedTypes);
  // console.log("root path", config.rootPath, file.path);

  var fileRelative = void 0;
  if (_path2.default.isAbsolute(file.path)) {
    fileRelative = _path2.default.relative(rootPath, file.path);
  } else {
    fileRelative = file.path;
  }

  var importMap = {};
  [].concat(_toConsumableArray(missedIdentifiers), _toConsumableArray(missedTypes)).forEach(function (identifier) {
    var importInfo = _getImport(fileRelative, identifier);

    if (!importInfo) {
      /* eslint-disable no-console */
      console.error("Could not find path for identifier '" + identifier + "'");
      /* eslint-enable no-console */
      return;
    }

    var exportKind = importInfo.exportKind,
        path_ = importInfo.path,
        actualName = importInfo.actualName;


    if (!importMap[exportKind]) {
      importMap[exportKind] = {};
    }

    var mapKind = importMap[exportKind];

    if (!mapKind[path_]) {
      mapKind[path_] = {
        // importKind: exportKind,
        others: []
      };
    }

    if (importInfo.defaultImport) {
      mapKind[path_].main = identifier;
    } else {
      var identifier_ = actualName != null ? actualName + " as " + identifier : identifier;
      mapKind[path_].others = [].concat(_toConsumableArray(mapKind[path_].others), [identifier_]);
    }
  });

  // console.log("import map", importMap);
  (0, _ImportUtils.updateImport)(ast, importMap);

  // Add import
  var result = ast.toSource();

  // Remove the empty line between 2 imports
  // The following code is wrong when the import has multiple line
  // while (true) {
  //   const result2 = result.replace(
  //     /(import[^\n]+from[^\n]+)\n{2,}import/g,
  //     "$1\nimport",
  //   );
  //   if (result2 === result) {
  //     break;
  //   }

  //   result = result2;
  // }

  return result;
};

var transformByConfigProvider = exports.transformByConfigProvider = function transformByConfigProvider(file, api, configProvider) {
  return baseTransform(file, api, configProvider.getFullRootPath(), configProvider.getImport, configProvider.getImport);
};