"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _lodash = require("lodash");

var _recast = require("recast");

var _recast2 = _interopRequireDefault(_recast);

var _Query = require("./utils/Query");

var _Detect = require("./utils/Detect");

var _HTMLTags = require("./utils/HTMLTags");

var _BuiltinIdentifiers = require("./utils/BuiltinIdentifiers");

var _DetectImportedIdentifier = require("./DetectImportedIdentifier");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var types = _recast2.default.types.namedTypes;

// Input: class A extends Component {}
// Output: [Component]
// Input: class A extends React.Component {}
// Output: [React]
var SuperClassIdentifier = (0, _Query.withQueryTransform)({
  query: types.ClassDeclaration,
  // filter: {
  //   // superClass: {
  //     // type: "Identifier",
  //   // },
  // },
  flatNodeTransform: function flatNodeTransform(node) {
    var ret = [];

    var superClass = node.superClass;

    if (superClass) {
      switch (superClass.type) {
        case "Identifier":
          ret.push(superClass.name);

          break;
        case "MemberExpression":
          if ((0, _Query.isIdentifier)(superClass.object)) {
            ret.push(superClass.object.name);
          }
          break;

        default:
          break;
      }
    }

    return ret;
  }
});

var CallMemberIdentifiers = (0, _Query.withQueryTransform)({
  query: types.CallExpression,
  filter: {
    callee: {
      type: "MemberExpression",
      object: {
        type: "Identifier"
      }
    }
  },
  nodeTransform: function nodeTransform(node) {
    return node.callee.object.name;
  }
});

// input: a()
// output: ["a"]
var CallExpressionIdentifier = (0, _Query.withQueryTransform)({
  query: types.CallExpression,
  filter: {
    callee: {
      type: "Identifier"
    }
  },
  nodeTransform: function nodeTransform(node) {
    return node.callee.name;
  }
});

var CallExpressionParamsIdentifier = (0, _Query.withQueryTransform)({
  query: types.CallExpression,
  filter: {
    arguments: []
  },
  flatNodeTransform: function flatNodeTransform(node) {
    return node.arguments.filter(_Query.isIdentifier).map(function (item) {
      return item.name;
    });
  }
});
// console.log("call", callIdentifiers2);

// input: const a = x;
// output: ["x"]
var VarAssignToIdentifier = (0, _Query.withQueryTransform)({
  query: types.VariableDeclarator,
  filter: {
    init: {
      type: "Identifier"
    }
  },
  nodeTransform: function nodeTransform(node) {
    return node.init.name;
  }
});

// input: switch (A) {};
// output: ["A"]
var SwitchIdentifier = (0, _Query.withQueryTransform)({
  query: types.SwitchStatement,
  filter: {
    discriminant: {
      type: "Identifier"
    }
  },
  nodeTransform: function nodeTransform(node) {
    return node.discriminant.name;
  }
});

// input: switch (A) { case B: ...};
// output: ["A", "B"]
var SwitchCaseIdentifier = (0, _Query.withQueryTransform)({
  query: types.SwitchCase,
  filter: {
    test: {
      type: "Identifier"
    }
  },
  nodeTransform: function nodeTransform(node) {
    return node.test.name;
  }
});

// input: return x;
// output: ["x"]
var ReturnIdentifier = (0, _Query.withQueryTransform)({
  query: types.ReturnStatement,
  filter: {
    argument: {
      type: "Identifier"
    }
  },
  nodeTransform: function nodeTransform(node) {
    return node.argument.name;
  }
});

// input: const a = {x: {y: B, [z]: C}};
// output: ["B", "z", "C"]
var ObjectExpressionIdentifier = (0, _Query.withQueryTransform)({
  query: types.ObjectExpression,
  flatNodeTransform: function flatNodeTransform(node) {
    return [].concat(_toConsumableArray(node.properties.filter(function (item) {
      return item.type === "Property" && (0, _Query.isIdentifier)(item.value);
    }).map(function (item) {
      return item.value.name;
    })), _toConsumableArray(node.properties.filter(function (item) {
      return item.type === "Property" && (0, _Query.isIdentifier)(item.key) && item.computed;
    }).map(function (item) {
      return item.key.name;
    })));
  }
});

// superClass identifier
var SuperClassIdentifier2 = {
  type: "ClassExpression",
  process: function process(_ref) {
    var child = _ref.child;

    // console.log("child name", child.name);
    if (child.name === "superClass") {
      return child.node.name;
    }
  }
};

var MemberExpression2 = {
  type: "MemberExpression",
  process: function process(_ref2) {
    var child = _ref2.child,
        path = _ref2.path;

    if (path.name === "object") {
      return path.node.name;
    }
  }
};

var JSXExpressionContainer = {
  type: "JSXExpressionContainer",
  process: function process(_ref3) {
    var child = _ref3.child,
        path = _ref3.path;

    if (path.name === "expression") {
      return path.node.name;
    }
  }
};

var StopPropertyKeyIdentifier = {
  type: "Property",
  process: function process(_ref4) {
    var child = _ref4.child,
        path = _ref4.path;

    if (path.name === "key") {
      return _Detect.STOP_PROCESS;
    }
  }
};

var StopMemberExpressionPropertyIdentifier = {
  type: "MemberExpression",
  process: function process(_ref5) {
    var child = _ref5.child,
        path = _ref5.path;

    if (path.name === "property") {
      return _Detect.STOP_PROCESS;
    }
  }
};

var StopHTMLJSXIdentifier = {
  type: "JSXOpeningElement",
  process: function process(_ref6) {
    var child = _ref6.child,
        path = _ref6.path;

    if (path.node.type === "JSXIdentifier" && _HTMLTags.htmlTags.has(path.node.name)) {
      return _Detect.STOP_PROCESS;
    }
  }
};

var StopGenericTypeAnnotation = {
  type: "GenericTypeAnnotation",
  process: function process(_ref7) {
    var child = _ref7.child,
        path = _ref7.path;

    // console.log(child.name);
    return _Detect.STOP_PROCESS;
  }
};

var StopArrowFunctionExpressionParams = {
  type: "ArrowFunctionExpression",
  process: function process(_ref8) {
    var child = _ref8.child,
        path = _ref8.path;

    // console.log(child.parentPath.name);
    if (child.parentPath.name === "params") {
      return _Detect.STOP_PROCESS;
    }
  }
};

var StopJSXAttributeIdentifier = {
  type: "JSXAttribute",
  process: function process(_ref9) {
    var child = _ref9.child,
        path = _ref9.path;

    if (child.name === "name") {
      return _Detect.STOP_PROCESS;
    }
  }
};

var Property2 = {
  type: "Property",
  process: function process(_ref10) {
    var child = _ref10.child,
        path = _ref10.path;

    if (path.name === "value") {
      return path.node.name;
    }
  }
};

var JSXIdentifier = {
  type: "JSXOpeningElement",
  process: function process(_ref11) {
    var child = _ref11.child,
        path = _ref11.path;

    if (path.name === "name") {
      return path.node.name;
    }
  }
};

// const A = B + C => B,C is undefined identifiers
// Fail case: const a = <Abc x />; => x is detected as identifier
var VariableDeclarator2 = {
  type: "VariableDeclarator",
  process: function process(_ref12) {
    var child = _ref12.child,
        path = _ref12.path;

    // console.log("cn", child.name, path.node.name);
    if (child.name === "init") {
      return path.node.name;
    }
  }
};

// class A extends B<T> {} => [B, T]
// const ClassExtendsGenericType = {
//   type: "GenericTypeAnnotation",
//   process: ({ child, path }) => {
//     // console.log("cn", child.name, path.node.name);
//     // console.log("a");
//     if (child.name === "superTypeParameters") {
//       return path.node.name;
//     }
//   },
// };

// Fail on case 'props.a + 1' => a is detected as identifier
// const BinaryExpression2 = {
//   type: "BinaryExpression",
//   process: ({ child, path }) => {
//     return path.node.name;
//   },
// };

// Detect identifier by lookup its parent
var parentMissedIdentifier = function parentMissedIdentifier(ast) {
  var ret = new Set();
  var myDetect = (0, _Detect.detectIdentifiers)(StopPropertyKeyIdentifier, StopMemberExpressionPropertyIdentifier, StopJSXAttributeIdentifier, StopHTMLJSXIdentifier, StopGenericTypeAnnotation, StopArrowFunctionExpressionParams, SuperClassIdentifier2, MemberExpression2, JSXExpressionContainer, VariableDeclarator2, Property2, JSXIdentifier
  // ClassExtendsGenericType
  // BinaryExpression2
  );

  // console.log(JSON.stringify(ast.nodes(), null, 2));
  // ast.find(types.GenericTypeAnnotation).forEach(path => {
  //   console.log("path1", path.node.name);
  //   // const items = myDetect(path);
  //   // for (const item of items) {
  //   //   ret.add(item);
  //   // }
  // });
  ast.find(types.Identifier).forEach(function (path) {
    // console.log("path", path.node.name);
    var items = myDetect(path);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var item = _step.value;

        ret.add(item);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  });

  // console.log("parent");
  return [].concat(_toConsumableArray(ret));
};

exports.default = function (ast) {
  // console.log("aaaa1");
  var importedIdentifiers = (0, _DetectImportedIdentifier.detectImportedIdentifiers)(ast);
  // console.log("imported", importedIdentifiers);

  importedIdentifiers = (0, _lodash.uniq)([].concat(_toConsumableArray(importedIdentifiers), _toConsumableArray(_BuiltinIdentifiers.builtinGlobal)));

  var identifiers = (0, _Query.compose)(CallMemberIdentifiers, CallExpressionIdentifier, VarAssignToIdentifier, SuperClassIdentifier, ReturnIdentifier, CallExpressionParamsIdentifier,
  // JSXIdentifiers,
  SwitchIdentifier, SwitchCaseIdentifier, ObjectExpressionIdentifier,
  // This one will be used to replace above detection
  parentMissedIdentifier)(ast);

  // Check is has JSX
  if (identifiers.indexOf("React") < 0 && ast.findJSXElements().size() > 0) {
    identifiers.push("React");
  }

  identifiers = (0, _lodash.uniq)(identifiers);
  // console.log("identi", identifiers);

  // Missed identifers
  return (0, _lodash.difference)(identifiers, importedIdentifiers);
};