"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUndefinedIdentifier = getUndefinedIdentifier;

var _eslint = require("eslint");

var _lodash = require("lodash");

var _BuiltinIdentifiers = require("./utils/BuiltinIdentifiers");

var cli = new _eslint.CLIEngine({
  useEslintrc: false,
  extends: "react-app1",
  rules: {
    "react/jsx-no-undef": "error",
    "react/react-in-jsx-scope": "error",
    // "flowtype/define-flow-type": "error",
    // "flowtype/use-flow-type": "error",
    "flowtype/define-flow-type": "error",
    "flowtype/require-valid-file-annotation": "error",
    "flowtype/use-flow-type": "error",
    "no-undef": "error",
    "no-unused-vars": "error"
  },
  env: {
    node: true
  },
  // extends: "react-app",
  parser: "babel-eslint",
  parserOptions: {
    ecmaVersion: 6,
    sourceType: "module",
    ecmaFeatures: {
      jsx: true,
      generators: true,
      experimentalObjectRestSpread: true
    }
  },
  plugins: ["import", "react", "flowtype"]
  // 'import', 'flowtype', 'jsx-a11y', 'react'
  // plugins: ["react-app"],
});


var identifierRegex = /'(.*)'/;
var flowTypeRegex = /^\s*type\s+(\w+)/;

function _parseIdenfierFromMsg(message) {
  var found = message.match(identifierRegex);

  // console.log(found);
  // $FlowFixMe
  return found[1];
}

function _errorToIdentifier(item) {
  var found = item.source.match(flowTypeRegex);
  // console.log("f", found);

  if (found != null) {
    // item.source is 'type XXX = ' => ignore
    return false;
  }

  var identifier = _parseIdenfierFromMsg(item.message);
  if (_BuiltinIdentifiers.builtinGlobal.has(identifier)) {
    return false;
  }

  return identifier;
}

function _getUndefineIdentifierFromMessages(messages) {
  var undefinedIdentifiers = messages.filter(function (item) {
    return item.ruleId === "no-undef" || item.ruleId === "react/jsx-no-undef";
  }).map(_errorToIdentifier).filter(function (identifier) {
    return identifier !== false;
  });

  var missedReact = messages.filter(function (item) {
    return item.ruleId === "react/react-in-jsx-scope";
  }).length > 0;

  if (missedReact) {
    undefinedIdentifiers = undefinedIdentifiers.concat("React");
  }

  // console.log(undefinedIdentifiers);
  return (0, _lodash.uniq)(undefinedIdentifiers);
}

function _getUnusedImportIdentifierFromMessages(messages) {
  var unusedIdentifiers = messages.filter(function (item) {
    return item.ruleId === "no-unused-vars";
  }).filter(function (item) {
    return item.source.trim().startsWith("import ");
  }).map(_errorToIdentifier).filter(function (identifier) {
    return identifier !== false;
  });

  // const missedReact =
  //   messages.filter(item => item.ruleId === "react/react-in-jsx-scope")
  //     .length === 0;

  // if (missedReact) {
  //   remove(unusedIdentifiers, item => item === "React");
  // }

  // console.log(unusedIdentifiers);
  return (0, _lodash.uniq)(unusedIdentifiers);
}

/**
 * @deprecated Use getErrorIdentifiers() instead
 *
 * @param {string} code
 */
function getUndefinedIdentifier(code) {
  var out = cli.executeOnText(code);
  var messages = (0, _lodash.flatMap)(out.results, function (results) {
    return results.messages;
  });
  // console.log(messages);

  return _getUndefineIdentifierFromMessages(messages);
}

/**
 * Get undefined and unused identifiers
 */
// export function getErrorIdentifiers(code: string): Object {
//   const out = cli.executeOnText(code);
//   const messages = flatMap(out.results, results => results.messages);
//   console.log(messages);

//   let undefinedIdentifiers = _getUndefineIdentifierFromMessages(messages);
//   let unusedIdentifiers = _getUnusedImportIdentifierFromMessages(messages);

//   return {
//     undefined: undefinedIdentifiers,
//     unused: unusedIdentifiers,
//   };
// }