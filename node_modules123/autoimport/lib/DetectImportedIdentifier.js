"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.detectImportedIdentifiers = undefined;

var _recast = require("recast");

var _recast2 = _interopRequireDefault(_recast);

var _Query = require("./utils/Query");

var _lodash = require("lodash");

var _Detect = require("./utils/Detect");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var types = _recast2.default.types.namedTypes;

// input: import A from 'a';
// output: [A]
var ImportedIdentifiers = (0, _Query.withQueryTransform)({
  query: types.ImportDeclaration,
  filter: {
    importKind: "value"
  },
  flatNodeTransform: function flatNodeTransform(node) {
    return node.specifiers.map(function (item) {
      return item.local.name;
    });
  }
});

// Input: class A extends Component {}
// Output: [A]
var DeclaredClassIdentifier = (0, _Query.withQueryTransform)({
  query: types.ClassDeclaration,
  flatNodeTransform: function flatNodeTransform(node) {
    var ret = [];

    if (node.id && (0, _Query.isIdentifier)(node.id)) {
      ret.push(node.id.name);
    }

    return ret;
  }
});

var DeclaredIdentifiers = (0, _Query.withQueryTransform)({
  query: types.VariableDeclarator,
  filter: {
    id: {
      type: "Identifier"
    }
  },
  nodeTransform: function nodeTransform(node) {
    return node.id.name;
  }
});

// Input: const {a, b: b1, ...c} = {}
// Output: [a, b1, c]
var VarObjectPatternIdentifiers = (0, _Query.withQueryTransform)({
  query: types.VariableDeclarator,
  filter: {
    id: {
      type: "ObjectPattern"
    }
  },
  flatNodeTransform: function flatNodeTransform(node) {
    // console.log(JSON.stringify(node.id, null, 2));
    return [].concat(_toConsumableArray(node.id.properties.filter(function (item) {
      return item.type === "Property" && (0, _Query.isIdentifier)(item.value);
    }).map(function (item) {
      return item.value.name;
    })), _toConsumableArray(node.id.properties.filter(function (item) {
      return item.type === "RestProperty" && (0, _Query.isIdentifier)(item.argument);
    }).map(function (item) {
      return item.argument.name;
    })));
  }
});

var FuncParamsIdentifiers = (0, _Query.withQueryTransform)({
  query: types.FunctionDeclaration,
  filter: {
    params: []
  },
  flatNodeTransform: function flatNodeTransform(node) {
    return node.params.filter(_Query.isIdentifier).map(function (item) {
      return item.name;
    });
  }
});

var ArrowFuncParamsIdentifiers = (0, _Query.withQueryTransform)({
  query: types.ArrowFunctionExpression,
  flatNodeTransform: function flatNodeTransform(node) {
    return node.params.filter(_Query.isIdentifier).map(function (item) {
      return item.name;
    });
  }
});

function _getIdentifiersFromParams(params) {
  var x = params.filter(_Query.isObjectPattern);
  // $FlowFixMe
  var objectPatternIdentifiers = (0, _lodash.flatMap)(x, function (item) {
    return item.properties.filter(function (item2) {
      return item2.value;
    }).map(function (item2) {
      return item2.value.name;
    });
  });

  var y = params.filter(_Query.isIdentifier).map(function (item) {
    return item.name;
  });
  return [].concat(_toConsumableArray(objectPatternIdentifiers), _toConsumableArray(y));
}

// Input: const a = { x(value) {}}
// Output: ["a", "value"]
var FunctionExpressionParamsIdentifiers = (0, _Query.withQueryTransform)({
  query: types.FunctionExpression,
  flatNodeTransform: function flatNodeTransform(node) {
    // return node.params.filter(_isIdentifier).map(item => item.name);
    return _getIdentifiersFromParams(node.params);
  }
});

// input: function x(y){}
// output: ["x"]
var FuncIdentifier = (0, _Query.withQueryTransform)({
  query: types.FunctionDeclaration,
  nodeTransform: function nodeTransform(node) {
    return node.id.name;
  }
});
// console.log("func vars", funcVars);

// ignore identifier in variable->init
var StopVariableDeclaratorInit = {
  type: "VariableDeclarator",
  process: function process(_ref) {
    var child = _ref.child;

    if (child.name === "init") {
      return _Detect.STOP_PROCESS;
    }
  }
};

var ArrowFunctionExpressionParams = {
  type: "ArrowFunctionExpression",
  process: function process(_ref2) {
    var child = _ref2.child,
        path = _ref2.path;

    // if (path.node.name === "b") {
    //   console.log(path.node.name, child.parentPath.name);
    // }
    if (child.parentPath.name === "params") {
      return path.node.name;
    }
  }
};

// Detect identifier by lookup its parent
var parentImportedIdentifier = function parentImportedIdentifier(ast) {
  var ret = new Set();
  var myDetect = (0, _Detect.detectIdentifiers)(
  // Arrow function expression params must be before StopVar
  ArrowFunctionExpressionParams, StopVariableDeclaratorInit);

  ast.find(types.Identifier).forEach(function (path) {
    var items = myDetect(path);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var item = _step.value;

        ret.add(item);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  });

  // console.log("parent");
  return [].concat(_toConsumableArray(ret));
};

var detectImportedIdentifiers = exports.detectImportedIdentifiers = (0, _Query.compose)(DeclaredIdentifiers, ImportedIdentifiers, FuncIdentifier, FuncParamsIdentifiers, ArrowFuncParamsIdentifiers, VarObjectPatternIdentifiers, FunctionExpressionParamsIdentifiers, DeclaredClassIdentifier,
// Will be used to replace abover identifier detection
parentImportedIdentifier);