"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeImportIdentifiers = removeImportIdentifiers;

var _lodash = require("lodash");

var _recast = require("recast");

var _recast2 = _interopRequireDefault(_recast);

var _DetectFlowType = require("./DetectFlowType");

var _DetectUndefESLint = require("./DetectUndefESLint");

var _Detect = require("./utils/Detect");

var _HTMLTags = require("./utils/HTMLTags");

var _Query = require("./utils/Query");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var types = _recast2.default.types.namedTypes;

// Input: class A extends Component {}
// Output: [Component]
// Input: class A extends React.Component {}
// Output: [React]
var SuperClassIdentifier = (0, _Query.withQueryTransform)({
  query: types.ClassDeclaration,
  // filter: {
  //   // superClass: {
  //     // type: "Identifier",
  //   // },
  // },
  flatNodeTransform: function flatNodeTransform(node) {
    var ret = [];

    var superClass = node.superClass;

    if (superClass) {
      switch (superClass.type) {
        case "Identifier":
          ret.push(superClass.name);

          break;
        case "MemberExpression":
          if ((0, _Query.isIdentifier)(superClass.object)) {
            ret.push(superClass.object.name);
          }
          break;

        default:
          break;
      }
    }

    return ret;
  }
});

var CallMemberIdentifiers = (0, _Query.withQueryTransform)({
  query: types.CallExpression,
  filter: {
    callee: {
      type: "MemberExpression",
      object: {
        type: "Identifier"
      }
    }
  },
  nodeTransform: function nodeTransform(node) {
    return node.callee.object.name;
  }
});

// input: a()
// output: ["a"]
var CallExpressionIdentifier = (0, _Query.withQueryTransform)({
  query: types.CallExpression,
  filter: {
    callee: {
      type: "Identifier"
    }
  },
  nodeTransform: function nodeTransform(node) {
    return node.callee.name;
  }
});

var CallExpressionParamsIdentifier = (0, _Query.withQueryTransform)({
  query: types.CallExpression,
  filter: {
    arguments: []
  },
  flatNodeTransform: function flatNodeTransform(node) {
    return node.arguments.filter(_Query.isIdentifier).map(function (item) {
      return item.name;
    });
  }
});
// console.log("call", callIdentifiers2);

// input: const a = x;
// output: ["x"]
var VarAssignToIdentifier = (0, _Query.withQueryTransform)({
  query: types.VariableDeclarator,
  filter: {
    init: {
      type: "Identifier"
    }
  },
  nodeTransform: function nodeTransform(node) {
    return node.init.name;
  }
});

// input: switch (A) {};
// output: ["A"]
var SwitchIdentifier = (0, _Query.withQueryTransform)({
  query: types.SwitchStatement,
  filter: {
    discriminant: {
      type: "Identifier"
    }
  },
  nodeTransform: function nodeTransform(node) {
    return node.discriminant.name;
  }
});

// input: switch (A) { case B: ...};
// output: ["A", "B"]
var SwitchCaseIdentifier = (0, _Query.withQueryTransform)({
  query: types.SwitchCase,
  filter: {
    test: {
      type: "Identifier"
    }
  },
  nodeTransform: function nodeTransform(node) {
    return node.test.name;
  }
});

// input: return x;
// output: ["x"]
var ReturnIdentifier = (0, _Query.withQueryTransform)({
  query: types.ReturnStatement,
  filter: {
    argument: {
      type: "Identifier"
    }
  },
  nodeTransform: function nodeTransform(node) {
    return node.argument.name;
  }
});

// input: const a = {x: {y: B, [z]: C}};
// output: ["B", "z", "C"]
var ObjectExpressionIdentifier = (0, _Query.withQueryTransform)({
  query: types.ObjectExpression,
  flatNodeTransform: function flatNodeTransform(node) {
    return [].concat(_toConsumableArray(node.properties.filter(function (item) {
      return item.type === "Property" && (0, _Query.isIdentifier)(item.value);
    }).map(function (item) {
      return item.value.name;
    })), _toConsumableArray(node.properties.filter(function (item) {
      return item.type === "Property" && (0, _Query.isIdentifier)(item.key) && item.computed;
    }).map(function (item) {
      return item.key.name;
    })));
  }
});

// superClass identifier
var SuperClassIdentifier2 = {
  type: "ClassExpression",
  process: function process(_ref) {
    var child = _ref.child;

    // console.log("child name", child.name);
    if (child.name === "superClass") {
      return child.node.name;
    }
  }
};

var MemberExpression2 = {
  type: "MemberExpression",
  process: function process(_ref2) {
    var child = _ref2.child,
        path = _ref2.path;

    if (path.name === "object") {
      return path.node.name;
    }
  }
};

var JSXExpressionContainer = {
  type: "JSXExpressionContainer",
  process: function process(_ref3) {
    var child = _ref3.child,
        path = _ref3.path;

    if (path.name === "expression") {
      return path.node.name;
    }
  }
};

var StopPropertyKeyIdentifier = {
  type: "Property",
  process: function process(_ref4) {
    var child = _ref4.child,
        path = _ref4.path;

    if (path.name === "key") {
      return _Detect.STOP_PROCESS;
    }
  }
};

var StopMemberExpressionPropertyIdentifier = {
  type: "MemberExpression",
  process: function process(_ref5) {
    var child = _ref5.child,
        path = _ref5.path;

    if (path.name === "property") {
      return _Detect.STOP_PROCESS;
    }
  }
};

var StopHTMLJSXIdentifier = {
  type: "JSXOpeningElement",
  process: function process(_ref6) {
    var child = _ref6.child,
        path = _ref6.path;

    if (path.node.type === "JSXIdentifier" && _HTMLTags.htmlTags.has(path.node.name)) {
      return _Detect.STOP_PROCESS;
    }
  }
};

var StopGenericTypeAnnotation = {
  type: "GenericTypeAnnotation",
  process: function process(_ref7) {
    var child = _ref7.child,
        path = _ref7.path;

    // console.log(child.name);
    return _Detect.STOP_PROCESS;
  }
};

var StopArrowFunctionExpressionParams = {
  type: "ArrowFunctionExpression",
  process: function process(_ref8) {
    var child = _ref8.child,
        path = _ref8.path;

    // console.log(child.parentPath.name);
    if (child.parentPath.name === "params") {
      return _Detect.STOP_PROCESS;
    }
  }
};

var StopJSXAttributeIdentifier = {
  type: "JSXAttribute",
  process: function process(_ref9) {
    var child = _ref9.child,
        path = _ref9.path;

    if (child.name === "name") {
      return _Detect.STOP_PROCESS;
    }
  }
};

var Property2 = {
  type: "Property",
  process: function process(_ref10) {
    var child = _ref10.child,
        path = _ref10.path;

    if (path.name === "value") {
      return path.node.name;
    }
  }
};

var JSXIdentifier = {
  type: "JSXOpeningElement",
  process: function process(_ref11) {
    var child = _ref11.child,
        path = _ref11.path;

    if (path.name === "name") {
      return path.node.name;
    }
  }
};

// const A = B + C => B,C is undefined identifiers
// Fail case: const a = <Abc x />; => x is detected as identifier
var VariableDeclarator2 = {
  type: "VariableDeclarator",
  process: function process(_ref12) {
    var child = _ref12.child,
        path = _ref12.path;

    // console.log("cn", child.name, path.node.name);
    if (child.name === "init") {
      return path.node.name;
    }
  }
};

// class A extends B<T> {} => [B, T]
var ClassExtendsGenericType = {
  type: "GenericTypeAnnotation",
  process: function process(_ref13) {
    var child = _ref13.child,
        path = _ref13.path;

    // console.log("cn", child.name, path.node.name);
    // console.log("a");
    if (child.name === "superTypeParameters") {
      return path.node.name;
    }
  }
};

// Fail on case 'props.a + 1' => a is detected as identifier
// const BinaryExpression2 = {
//   type: "BinaryExpression",
//   process: ({ child, path }) => {
//     return path.node.name;
//   },
// };

// Detect identifier by lookup its parent
var parentMissedIdentifier = function parentMissedIdentifier(ast) {
  var ret = new Set();
  var myDetect = (0, _Detect.detectIdentifiers)(StopPropertyKeyIdentifier, StopMemberExpressionPropertyIdentifier, StopJSXAttributeIdentifier, StopHTMLJSXIdentifier, StopGenericTypeAnnotation, StopArrowFunctionExpressionParams, SuperClassIdentifier2, MemberExpression2, JSXExpressionContainer, VariableDeclarator2, Property2, JSXIdentifier
  // ClassExtendsGenericType
  // BinaryExpression2
  );

  // console.log(JSON.stringify(ast.nodes(), null, 2));
  // ast.find(types.GenericTypeAnnotation).forEach(path => {
  //   console.log("path1", path.node.name);
  //   // const items = myDetect(path);
  //   // for (const item of items) {
  //   //   ret.add(item);
  //   // }
  // });
  ast.find(types.Identifier).forEach(function (path) {
    // console.log("path", path.node.name);
    var items = myDetect(path);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var item = _step.value;

        ret.add(item);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  });

  // console.log("parent");
  return [].concat(_toConsumableArray(ret));
};

var _isImportPath = function _isImportPath(path) {
  return path.node.type === "ImportSpecifier" || path.node.type === "ImportDefaultSpecifier";
};
var _isFlowTypeAnnotationPath = function _isFlowTypeAnnotationPath(path) {
  return path.node.type === "GenericTypeAnnotation";
};

function getUnusedImports(ast) {
  var unusedImports = new Set();

  // console.log(ast.toSource());

  // ast.find(types.Identifier).forEach(path => {
  //   console.log("b", path.node.name);
  // });
  // Find all import identifiers
  ast.find(types.ImportDeclaration).forEach(function (path) {
    path.node.specifiers.forEach(function (item) {
      return unusedImports.add(item.local.name);
    });
  });

  // Remove identifiers which in not in import path
  ast.find(types.Identifier).forEach(function (path) {
    // console.log(
    //   "a",
    //   path.node.name,
    //   path.parent.node.type,
    //   "notImportPath",
    //   !_isImportPath(path.parent),
    //   "_isFlowTypeAnnotationPath",
    //   _isFlowTypeAnnotationPath(path.parent),
    // );

    if (!_isImportPath(path.parent) || _isFlowTypeAnnotationPath(path.parent)) {
      unusedImports.delete(path.node.name);
    }
  });

  // Remove type identifiers which in import path

  var hasReact = ast.find(types.JSXElement).size() > 0;

  if (hasReact) {
    // Remove React from unused imports
    unusedImports.delete("React");
  }

  return [].concat(_toConsumableArray(unusedImports.values()));
}

function removeImportIdentifiers(j, ast, unusedImports) {
  ast.find(types.ImportDeclaration).forEach(function (path) {
    if (path.node.specifiers.length > 0) {
      // console.log("unusedImports", unusedImports);
      // console.log(path.node);
      path.node.specifiers = path.node.specifiers.filter(function (item) {
        // console.log(
        //   "check remove",
        //   item.local.name,
        //   unusedImports,
        //   unusedImports.indexOf(item.local.name) >= 0,
        // );
        return unusedImports.indexOf(item.local.name) < 0;
      });

      if (path.node.specifiers.length === 0) {
        // remove import
        // console.log("remove", path.node.source.raw);
        j(path).remove();
      }
    }
  });
}

var builtinGlobal = new Set(["JSON", "Object", "br", "iframe", "console", "alert"]);

exports.default = function (ast) {
  var undefinedIdentifiers = (0, _DetectUndefESLint.getUndefinedIdentifier)(ast.toSource());
  // const otherUndefinedIdentifiers = detectFlowType(ast);

  return {
    identifiers: undefinedIdentifiers,
    // identifiers: uniq([...undefinedIdentifiers, ...otherUndefinedIdentifiers]),
    unusedImports: getUnusedImports(ast),
    types: (0, _DetectFlowType.detectFlowType)(ast)
  };
};